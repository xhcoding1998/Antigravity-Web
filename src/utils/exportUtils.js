/**
 * å¯¼å‡ºå·¥å…·å‡½æ•°
 * æ”¯æŒå¯¼å‡ºä¸ºå›¾ç‰‡ã€PDFã€Markdownï¼Œå¹¶æ”¯æŒé¢„è§ˆ
 */

// --- æ ¸å¿ƒè¾…åŠ©å‡½æ•°ï¼šæ„å»º DOM ---

/**
 * HTMLè½¬ä¹‰
 */
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

/**
 * å‡†å¤‡å¯¼å‡ºå®¹å™¨çš„ DOM ç»“æ„ (macOS é£æ ¼)
 * @param {Array} messages - æ¶ˆæ¯åˆ—è¡¨
 * @param {string} title - æ ‡é¢˜
 * @param {boolean} isDark - ä¸»é¢˜
 * @param {Set} messageIndices - é€‰ä¸­çš„æ¶ˆæ¯ç´¢å¼•
 * @returns {HTMLElement} æ„å»ºå¥½çš„ DOM å…ƒç´ 
 */
export function prepareMacOSContainerDOM(messages, title = 'å¯¹è¯å¯¼å‡º', isDark = false, messageIndices = null) {
  const container = document.createElement('div');
  // é»˜è®¤æ ·å¼ï¼Œé€‚åˆç›´æ¥å±•ç¤º
  container.className = 'export-container-preview';
  container.style.width = '100%';
  container.style.maxWidth = '900px';
  container.style.margin = '0 auto';

  // macOSçª—å£æ ·å¼ï¼ˆä¸ SummaryModal.vue ç»Ÿä¸€ï¼‰
  const containerBg = isDark ? '#1e1e20' : '#ffffff';
  const headerBg = isDark ? '#2a2a2c' : '#f5f5f7';
  const headerBorder = isDark ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.05)';
  const textColor = isDark ? '#aaaaaa' : '#666666';

  container.innerHTML = `
    <div style="
      background: ${containerBg};
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
      border: 1px solid ${headerBorder};
    ">
      <!-- macOS çª—å£å¤´éƒ¨ -->
      <div style="
        background: ${headerBg};
        padding: 0 16px;
        height: 44px;
        display: flex;
        align-items: center;
        border-bottom: 1px solid ${headerBorder};
        position: relative;
      ">
        <!-- çº¢é»„ç»¿ä¸‰ä¸ªåœ†ç‚¹ -->
        <div style="display: flex; gap: 8px; align-items: center; z-index: 10;">
          <div style="width: 12px; height: 12px; border-radius: 50%; background: #ff5f56; border: 0.5px solid rgba(0,0,0,0.1);"></div>
          <div style="width: 12px; height: 12px; border-radius: 50%; background: #ffbd2e; border: 0.5px solid rgba(0,0,0,0.1);"></div>
          <div style="width: 12px; height: 12px; border-radius: 50%; background: #27c93f; border: 0.5px solid rgba(0,0,0,0.1);"></div>
        </div>

        <!-- æ ‡é¢˜ï¼ˆç»å¯¹å±…ä¸­ï¼‰ -->
        <div style="
            font-size: 13px;
            font-weight: 600;
            color: ${textColor};
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            white-space: nowrap;
        ">
            ${escapeHtml(title)}
        </div>
      </div>

      <!-- æ¶ˆæ¯å†…å®¹å®¹å™¨ -->
      <div id="messages-container" style="padding: 24px; background: ${containerBg};"></div>

      <!-- åº•éƒ¨ä¿¡æ¯ -->
      <div style="
        padding: 12px 24px;
        background: ${isDark ? '#252527' : '#fafafa'};
        border-top: 1px solid ${isDark ? 'rgba(255,255,255,0.03)' : 'rgba(0,0,0,0.03)'};
        font-size: 11px;
        color: ${isDark ? '#666' : '#bbb'};
        text-align: center;
        display: flex;
        justify-content: space-between;
      ">
        <span>Generated by Antigravity AI</span>
        <span>${new Date().toLocaleDateString()}</span>
      </div>
    </div>
  `;

  // è·å–æ¶ˆæ¯å®¹å™¨
  const messagesContainer = container.querySelector('#messages-container');

  // è·å–é¡µé¢ä¸ŠçœŸå®çš„æ¶ˆæ¯å…ƒç´ 
  const messageElements = Array.from(document.querySelectorAll('.py-3.w-full.flex.justify-center'))
    .filter(el => {
      return el.querySelector('.flex.flex-col.gap-2.min-w-0.flex-1.relative');
    });

  const indicesToExport = messageIndices || new Set(Array.from({ length: messages.length }, (_, i) => i));

  let exportedCount = 0;

  messageElements.forEach((msgElement, index) => {
    if (indicesToExport.has(index) && exportedCount < messages.length) {
      const clonedMsg = msgElement.cloneNode(true);

      // DOM Cleanup & Styling Fixes

      // 1. Remove Checkboxes
      const checkbox = clonedMsg.querySelector('input[type="checkbox"]');
      if (checkbox && checkbox.parentElement) {
        checkbox.parentElement.remove();
      }

      // 2. Fix Model Tag Style
      // æ¢å¤æ¼‚äº®çš„è§†è§‰æ ·å¼ï¼Œä½†ä½¿ç”¨å¯¹ html2canvas å‹å¥½çš„æ˜¾å¼ CSS
      const modelTag = clonedMsg.querySelector('span[class*="bg-blue-100"], span[class*="bg-chatgpt-"]');
      if (modelTag) {
          // æ¸…é™¤å¯èƒ½å¯¼è‡´åç§»çš„ Tailwind ç±»å’Œæ ·å¼
          modelTag.className = '';
          modelTag.removeAttribute('style');

          Object.assign(modelTag.style, {
              display: 'inline-flex',
              alignItems: 'center',
              justifyContent: 'center',
              height: '18px',
              padding: '0 6px',
              marginLeft: '6px',
              backgroundColor: isDark ? 'rgba(59, 130, 246, 0.2)' : 'rgba(219, 234, 254, 1)', // blue-100 / dark
              color: isDark ? '#60a5fa' : '#1e40af', // blue-800 / blue-400
              borderRadius: '4px',
              fontSize: '10px',
              fontWeight: '500',
              fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace',
              lineHeight: '1',
              verticalAlign: 'middle',
              transform: 'none', // ç¦æ­¢å˜æ¢ï¼Œé˜²æ­¢åç§»
              border: isDark ? '1px solid rgba(59, 130, 246, 0.3)' : 'none'
          });

          // ç¡®ä¿çˆ¶å®¹å™¨å¯¹é½
          if (modelTag.parentElement) {
              modelTag.parentElement.style.display = 'flex';
              modelTag.parentElement.style.alignItems = 'center';
              modelTag.parentElement.style.flexWrap = 'wrap';
          }
      }

      // 3. Remove Action Buttons (except Code Copy)
      const actionButtons = clonedMsg.querySelectorAll('button');
      actionButtons.forEach(btn => {
        if (!btn.closest('.code-block-header')) {
          btn.remove();
        }
      });

      // 4. Force Width
      clonedMsg.style.width = '100%';
      clonedMsg.style.maxWidth = '100%';

      messagesContainer.appendChild(clonedMsg);
      exportedCount++;
    }
  });

  return container;
}

/**
 * ç”Ÿæˆ Markdown å†…å®¹
 */
export function generateMarkdownContent(messages, title = 'å¯¹è¯å¯¼å‡º', messageIndices = null) {
  let markdown = `# ${title}\n\n`;
  markdown += `> å¯¼å‡ºæ—¶é—´: ${new Date().toLocaleString('zh-CN')}\n\n`;
  markdown += `---\n\n`;

  const indicesToExport = messageIndices || new Set(Array.from({ length: messages.length }, (_, i) => i));

  messages.forEach((msg, index) => {
    if (!indicesToExport.has(index)) return;

    const role = msg.role === 'user' ? 'ğŸ‘¤ ç”¨æˆ·' : 'ğŸ¤– AI';
    const modelInfo = (msg.role !== 'user' && msg.modelId) ? ` (${msg.modelId})` : '';
    const time = msg.timestamp ? ` - ${new Date(msg.timestamp).toLocaleTimeString()}` : '';

    markdown += `## ${role}${modelInfo}${time}\n\n`;
    markdown += `${msg.content || ''}\n\n`;

    if (msg.images && msg.images.length > 0) {
      msg.images.forEach((img, idx) => {
        markdown += `![å›¾ç‰‡${idx + 1}](${img})\n\n`;
      });
    }

    markdown += `---\n\n`;
  });

  return markdown;
}


// --- æ ¸å¿ƒæ‰§è¡Œå‡½æ•°ï¼šä¸‹è½½ ---

/**
 * é€šç”¨æ¸²æŸ“å‡½æ•°ï¼šå°† DOM æ¸²æŸ“ä¸º Canvas
 * ä½¿ç”¨ Clone + ç¦»å±æ¸²æŸ“æŠ€æœ¯ï¼Œé¿å…æ»šåŠ¨æ¡å’Œè§†å£é™åˆ¶
 */
async function renderElementToCanvas(element) {
    const html2canvas = (await import('html2canvas')).default;

    // 1. Clone å…ƒç´ ï¼Œé¿å…å½±å“ç°æœ‰è§†å›¾
    const clone = element.cloneNode(true);

    // 2. è®¾ç½®å›ºå®šæ ·å¼ï¼Œç¡®ä¿å®Œæ•´æ¸²æŸ“
    Object.assign(clone.style, {
        position: 'fixed',
        left: '-10000px',
        top: '0',
        width: '800px', // å›ºå®šå®½åº¦ï¼Œç±»ä¼¼ A4 æ¯”ä¾‹æˆ–æ ‡å‡†ç½‘é¡µå®½
        height: 'auto',
        zIndex: '-1000',
        overflow: 'visible' // ç¡®ä¿å†…å®¹ä¸è¢«è£å‰ª
    });

    document.body.appendChild(clone);

    // ç­‰å¾…ä¸€å°æ®µæ—¶é—´ç¡®ä¿æ ·å¼åº”ç”¨å’ŒæŸäº›èµ„æºåŠ è½½
    await new Promise(resolve => setTimeout(resolve, 100));

    try {
        const canvas = await html2canvas(clone, {
            backgroundColor: null,
            scale: 2, // é«˜æ¸…
            logging: false,
            useCORS: true,
            allowTaint: true,
            foreignObjectRendering: false,
            windowWidth: clone.scrollWidth,
            windowHeight: clone.scrollHeight
        });
        return canvas;
    } finally {
        // æ¸…ç† Clone
        if (clone && clone.parentNode) {
            clone.parentNode.removeChild(clone);
        }
    }
}

/**
 * ä¸‹è½½ DOM ä¸ºå›¾ç‰‡
 */
export async function downloadDOMAsImage(element, filename) {
  try {
    const canvas = await renderElementToCanvas(element);

    const link = document.createElement('a');
    link.download = filename.endsWith('.png') ? filename : `${filename}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();

    return { success: true };
  } catch (error) {
    console.error('å¯¼å‡ºå›¾ç‰‡å¤±è´¥:', error);
    return { success: false, error: error.message };
  }
}

/**
 * ä¸‹è½½ DOM ä¸º PDF
 */
export async function downloadDOMAsPDF(element, filename) {
  try {
    const { jsPDF } = await import('jspdf');

    // ä½¿ç”¨é€šç”¨æ¸²æŸ“å‡½æ•°
    const canvas = await renderElementToCanvas(element);

    const imgData = canvas.toDataURL('image/png');
    // A4 å°ºå¯¸ (mm)
    const pdf = new jsPDF('p', 'mm', 'a4');
    const pdfWidth = 210;
    const pdfHeight = 297;

    // è®¡ç®—å›¾ç‰‡åœ¨ PDF ä¸­çš„å°ºå¯¸ï¼ˆä¿æŒæ¯”ä¾‹é€‚é…å®½åº¦ï¼‰
    const imgProps = pdf.getImageProperties(imgData);
    const imgHeight = (imgProps.height * pdfWidth) / imgProps.width;

    let heightLeft = imgHeight;
    let position = 0;

    // ç¬¬ä¸€é¡µ
    pdf.addImage(imgData, 'PNG', 0, position, pdfWidth, imgHeight);
    heightLeft -= pdfHeight;

    // åç»­é¡µ
    while (heightLeft > 0) {
      position = heightLeft - imgHeight; // è¿™é‡Œçš„è®¡ç®—æ˜¯: å½“å‰å‰©ä½™é¡¶éƒ¨ä½ç½®
      // å®é™…ä¸Š jspdf åˆ†é¡µæ·»åŠ å›¾ç‰‡çš„é€»è¾‘æ˜¯: è°ƒæ•´ y åæ ‡ä¸ºè´Ÿå€¼ï¼Œè®©å›¾ç‰‡ä¸Šç§»
      // position åº”è¯¥æ˜¯ -297, -594 ...
      // ä¿®æ­£ç®—æ³•ï¼š
      // Page 2: position should be -297

      pdf.addPage();
      // è®¡ç®—æ–°çš„åç§»é‡
      // ä¸Šä¸€æ¬¡çš„ position æ˜¯ 0ï¼ˆç›¸å¯¹äºç¬¬ä¸€é¡µé¡¶ç«¯ï¼‰
      // ä¸‹ä¸€é¡µæˆ‘ä»¬è¦æ˜¾ç¤ºçš„æ˜¯åŸæœ¬ 297mm å¤„çš„å†…å®¹ï¼Œè®©å®ƒå‡ºç°åœ¨æ–°é¡µé¢çš„ 0mm å¤„
      // æ‰€ä»¥ y = -297
      // æˆ‘ä»¬å¯ä»¥ç»´æŠ¤ä¸€ä¸ªç´¯åŠ çš„ offset

      // é‡ç½® position é€»è¾‘ï¼Œç›´æ¥ç”¨ page index
      const pageIndex = pdf.internal.getNumberOfPages() - 1; // 0-based, now 1
      position = -pageIndex * pdfHeight;

      pdf.addImage(imgData, 'PNG', 0, position, pdfWidth, imgHeight);
      heightLeft -= pdfHeight;
    }

    pdf.save(filename.endsWith('.pdf') ? filename : `${filename}.pdf`);
    return { success: true };
  } catch (error) {
    console.error('å¯¼å‡ºPDFå¤±è´¥:', error);
    return { success: false, error: error.message };
  }
}

/**
 * ä¸‹è½½ Markdown å­—ç¬¦ä¸²
 */
export function downloadMarkdownString(content, filename) {
    try {
        const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' });
        const link = document.createElement('a');
        link.download = filename.endsWith('.md') ? filename : `${filename}.md`;
        link.href = URL.createObjectURL(blob);
        link.click();
        URL.revokeObjectURL(link.href);
        return { success: true };
    } catch (error) {
        console.error('å¯¼å‡ºMarkdownå¤±è´¥:', error);
        return { success: false, error: error.message };
    }
}


// --- å…¼å®¹æ—§ API (Direct Export) ---

export async function exportAsImage(messages, title, isDark, messageIndices) {
    const element = prepareMacOSContainerDOM(messages, title, isDark, messageIndices);
    // æ”¾å…¥ body éšè—
    element.style.position = 'fixed';
    element.style.left = '-9999px';
    element.style.top = '0';
    document.body.appendChild(element);
    try {
        return await downloadDOMAsImage(element, `chat-export-${Date.now()}`);
    } finally {
        element.remove();
    }
}

export async function exportAsPDF(messages, title, isDark, messageIndices) {
    const element = prepareMacOSContainerDOM(messages, title, isDark, messageIndices);
    element.style.position = 'fixed';
    element.style.left = '-9999px';
    element.style.top = '0';
    document.body.appendChild(element);
    try {
        await new Promise(r => setTimeout(r, 100)); // wait for style
        return await downloadDOMAsPDF(element, `chat-export-${Date.now()}`);
    } finally {
        element.remove();
    }
}

export function exportAsMarkdown(messages, title, messageIndices) {
    const content = generateMarkdownContent(messages, title, messageIndices);
    return downloadMarkdownString(content, `chat-export-${Date.now()}`);
}
