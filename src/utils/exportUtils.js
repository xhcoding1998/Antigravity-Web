/**
 * å¯¼å‡ºå·¥å…·å‡½æ•°
 * æ”¯æŒå¯¼å‡ºä¸ºå›¾ç‰‡ã€PDFã€Markdownï¼Œå¹¶æ”¯æŒé¢„è§ˆ
 */

// --- æ ¸å¿ƒè¾…åŠ©å‡½æ•°ï¼šæ„å»º DOM ---

/**
 * HTMLè½¬ä¹‰
 */
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

/**
 * å‡†å¤‡å¯¼å‡ºå®¹å™¨çš„ DOM ç»“æ„ (macOS é£æ ¼)
 * @param {Array} messages - æ¶ˆæ¯åˆ—è¡¨
 * @param {string} title - æ ‡é¢˜
 * @param {boolean} isDark - ä¸»é¢˜
 * @param {Set} messageIndices - é€‰ä¸­çš„æ¶ˆæ¯ç´¢å¼•
 * @param {number} width - å®¹å™¨å®½åº¦
 * @returns {HTMLElement} æ„å»ºå¥½çš„ DOM å…ƒç´ 
 */
export function prepareMacOSContainerDOM(messages, title = 'å¯¹è¯å¯¼å‡º', isDark = false, messageIndices = null, width = 1000) {
  const isMobile = width <= 500;
  const container = document.createElement('div');
  // é»˜è®¤æ ·å¼ï¼Œé€‚åˆç›´æ¥å±•ç¤º
  container.className = 'export-container-preview';
  container.style.width = '100%'; // é»˜è®¤å¤–å±‚å®¹å™¨å®½ï¼Œå¦‚æœæ˜¯ mobileï¼Œå†…éƒ¨ content ä¼šè¢«å‹ç¼©
  if (isMobile) {
      container.style.width = `${width}px`;
  }
  container.style.margin = '0 auto';

  // macOSçª—å£æ ·å¼ï¼ˆä¸ SummaryModal.vue ç»Ÿä¸€ï¼‰
  const containerBg = isDark ? '#1e1e20' : '#ffffff';
  const headerBg = isDark ? '#2a2a2c' : '#f5f5f7';
  const headerBorder = isDark ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.05)';
  const textColor = isDark ? '#aaaaaa' : '#666666';

  // ç§»åŠ¨ç«¯ä¼˜åŒ–å‚æ•°
  const containerPadding = isMobile ? '8px' : '24px';
  const headerHeight = isMobile ? '38px' : '44px';
  const titleFontSize = isMobile ? '12px' : '13px';
  const headerPadding = isMobile ? '12px' : '16px';
  const dotSize = isMobile ? '10px' : '12px';
  const dotGap = isMobile ? '6px' : '8px';
  const footerPadding = isMobile ? '8px 12px' : '12px 24px';
  const footerFontSize = isMobile ? '10px' : '11px';

  container.innerHTML = `
    <div style="
      background: ${containerBg};
      border-radius: ${isMobile ? '12px' : '16px'};
      box-shadow: 0 0 0 1px rgba(0,0,0,0.02), 0 30px 80px rgba(0,0,0,0.15), 0 10px 30px rgba(0,0,0,0.05);
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
      border: 1px solid ${headerBorder};
    ">
      <!-- macOS çª—å£å¤´éƒ¨ -->
      <div style="
        background: ${headerBg};
        padding: 0 ${headerPadding};
        height: ${headerHeight};
        display: flex;
        align-items: center;
        border-bottom: 1px solid ${headerBorder};
        position: relative;
      ">
        <!-- çº¢é»„ç»¿ä¸‰ä¸ªåœ†ç‚¹ -->
        <div style="display: flex; gap: ${dotGap}; align-items: center; z-index: 10;">
          <div style="width: ${dotSize}; height: ${dotSize}; border-radius: 50%; background: #ff5f56; border: 0.5px solid rgba(0,0,0,0.1);"></div>
          <div style="width: ${dotSize}; height: ${dotSize}; border-radius: 50%; background: #ffbd2e; border: 0.5px solid rgba(0,0,0,0.1);"></div>
          <div style="width: ${dotSize}; height: ${dotSize}; border-radius: 50%; background: #27c93f; border: 0.5px solid rgba(0,0,0,0.1);"></div>
        </div>

        <!-- æ ‡é¢˜ï¼ˆç»å¯¹å±…ä¸­ï¼‰ -->
        <div style="
            font-size: ${titleFontSize};
            font-weight: 600;
            color: ${textColor};
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            white-space: nowrap;
            max-width: ${isMobile ? '60%' : '80%'};
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: center;
        ">
            ${escapeHtml(title)}
        </div>
      </div>

      <!-- æ¶ˆæ¯å†…å®¹å®¹å™¨ -->
      <div id="messages-container" style="padding: ${containerPadding}; background: ${containerBg};"></div>

      <!-- åº•éƒ¨ä¿¡æ¯ -->
      <div style="
        padding: ${footerPadding};
        background: ${isDark ? '#252527' : '#fafafa'};
        border-top: 1px solid ${isDark ? 'rgba(255,255,255,0.03)' : 'rgba(0,0,0,0.03)'};
        font-size: ${footerFontSize};
        color: ${isDark ? '#666' : '#bbb'};
        text-align: center;
        display: flex;
        justify-content: space-between;
      ">
        <span>Generated by Antigravity AI</span>
        <span>${new Date().toLocaleDateString()}</span>
      </div>
    </div>
  `;

  // è·å–æ¶ˆæ¯å®¹å™¨
  const messagesContainer = container.querySelector('#messages-container');

  // è·å–é¡µé¢ä¸ŠçœŸå®çš„æ¶ˆæ¯å…ƒç´ 
  const messageElements = Array.from(document.querySelectorAll('.py-3.w-full.flex.justify-center'))
    .filter(el => {
      return el.querySelector('.flex.flex-col.gap-2.min-w-0.flex-1.relative');
    });

  const indicesToExport = messageIndices || new Set(Array.from({ length: messages.length }, (_, i) => i));

  let exportedCount = 0;

  messageElements.forEach((msgElement, index) => {
    if (indicesToExport.has(index) && exportedCount < messages.length) {
      const clonedMsg = msgElement.cloneNode(true);

      // DOM Cleanup & Styling Fixes

      // 1. Remove Checkboxes
      const checkbox = clonedMsg.querySelector('input[type="checkbox"]');
      if (checkbox && checkbox.parentElement) {
        checkbox.parentElement.remove();
      }

      // 2. Fix Model Tag Style
      // åªå®šä½æ¶ˆæ¯å¤´éƒ¨çš„æ¨¡å‹IDæ ‡ç­¾ï¼Œä¸å½±å“å†…å®¹åŒºåŸŸçš„å…¶ä»–å…ƒç´ 
      // æ¨¡å‹æ ‡ç­¾ä½äº .flex.flex-col.gap-1 > .flex.items-center.gap-2 > span.font-mono ç»“æ„ä¸­
      const headerContainer = clonedMsg.querySelector('.flex.flex-col.gap-1.mb-1');
      if (headerContainer) {
          const nameRow = headerContainer.querySelector('.flex.items-center.gap-2');
          const modelTag = nameRow?.querySelector('span.font-mono');
          
          if (modelTag) {
              // æ¸…é™¤æ‰€æœ‰ Tailwind ç±»å’Œæ ·å¼ï¼Œä½¿ç”¨ç®€æ´çš„çº¯æ–‡æœ¬æ ·å¼ï¼ˆæ— èƒŒæ™¯æ— è¾¹æ¡†ï¼‰
              modelTag.className = '';
              modelTag.removeAttribute('style');

              Object.assign(modelTag.style, {
                  display: 'inline',
                  padding: '0',
                  margin: '0',
                  marginLeft: '4px',
                  backgroundColor: 'transparent',
                  color: isDark ? '#888888' : '#666666',
                  border: 'none',
                  borderRadius: '0',
                  fontSize: '10px',
                  fontWeight: '400',
                  fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace',
                  lineHeight: 'inherit',
                  verticalAlign: 'baseline'
              });
          }
      }

      // 3. Remove Action Buttons (except Code Copy)
      const actionButtons = clonedMsg.querySelectorAll('button');
      actionButtons.forEach(btn => {
        if (!btn.closest('.code-block-header')) {
          btn.remove();
        }
      });

      // 4. Force Width & Responsive Adjustments
      clonedMsg.style.width = '100%';
      clonedMsg.style.maxWidth = '100%';
      clonedMsg.style.padding = isMobile ? '8px 10px' : '24px 20px';

      // 5. Adjust Font Size & spacing for Mobile
      if (isMobile) {
          const contentWrapper = clonedMsg.querySelector('.max-w-4xl');
          if (contentWrapper) {
              contentWrapper.style.padding = '8px';
              contentWrapper.style.gap = '6px';
          }
          const textContainer = clonedMsg.querySelector('.prose, .markdown-body, [class*="text-"]');
          if (textContainer) {
              textContainer.style.fontSize = '12px';
              textContainer.style.lineHeight = '1.45';
              // è¿›ä¸€æ­¥ä¼˜åŒ–å†…éƒ¨é—´è·
              const paragraphs = textContainer.querySelectorAll('p, li, pre');
              paragraphs.forEach(p => {
                  p.style.marginTop = '2px';
                  p.style.marginBottom = '2px';
              });
              const codes = textContainer.querySelectorAll('pre code, .hljs');
              codes.forEach(c => {
                  c.style.fontSize = '11px';
                  c.style.lineHeight = '1.4';
              });
          }
          // Reduce avatar size
          const avatar = clonedMsg.querySelector('.w-8.h-8, .w-10.h-10');
          if (avatar) {
              avatar.style.width = '24px';
              avatar.style.height = '24px';
          }
      }

      messagesContainer.appendChild(clonedMsg);
      exportedCount++;
    }
  });

  return container;
}

/**
 * ç”Ÿæˆ Markdown å†…å®¹
 */
export function generateMarkdownContent(messages, title = 'å¯¹è¯å¯¼å‡º', messageIndices = null) {
  let markdown = `# ${title}\n\n`;
  markdown += `> å¯¼å‡ºæ—¶é—´: ${new Date().toLocaleString('zh-CN')}\n\n`;
  markdown += `---\n\n`;

  const indicesToExport = messageIndices || new Set(Array.from({ length: messages.length }, (_, i) => i));

  messages.forEach((msg, index) => {
    if (!indicesToExport.has(index)) return;

    const role = msg.role === 'user' ? 'ğŸ‘¤ ç”¨æˆ·' : 'ğŸ¤– AI';
    const modelInfo = (msg.role !== 'user' && msg.modelId) ? ` (${msg.modelId})` : '';
    const time = msg.timestamp ? ` - ${new Date(msg.timestamp).toLocaleTimeString()}` : '';

    markdown += `## ${role}${modelInfo}${time}\n\n`;
    markdown += `${msg.content || ''}\n\n`;

    if (msg.images && msg.images.length > 0) {
      msg.images.forEach((img, idx) => {
        markdown += `![å›¾ç‰‡${idx + 1}](${img})\n\n`;
      });
    }

    markdown += `---\n\n`;
  });

  return markdown;
}


// --- æ ¸å¿ƒæ‰§è¡Œå‡½æ•°ï¼šä¸‹è½½ ---

/**
 * é€šç”¨æ¸²æŸ“å‡½æ•°ï¼šå°† DOM æ¸²æŸ“ä¸º Canvas
 * ä½¿ç”¨ Clone + ç¦»å±æ¸²æŸ“æŠ€æœ¯ï¼Œé¿å…æ»šåŠ¨æ¡å’Œè§†å£é™åˆ¶
 */
async function renderElementToCanvas(element, options = {}) {
    const html2canvas = (await import('html2canvas')).default;
    const { width = 1000 } = options;

    // 1. Clone å…ƒç´ ï¼Œé¿å…å½±å“ç°æœ‰è§†å›¾
    const clone = element.cloneNode(true);

    // 2. è®¾ç½®å›ºå®šæ ·å¼ï¼Œç¡®ä¿å®Œæ•´æ¸²æŸ“
    Object.assign(clone.style, {
        position: 'fixed',
        left: '-10000px',
        top: '0',
        width: `${width}px`, // ä½¿ç”¨ä¼ å…¥çš„å®½åº¦
        height: 'auto',
        zIndex: '-1000',
        overflow: 'visible' // ç¡®ä¿å†…å®¹ä¸è¢«è£å‰ª
    });

    // 3. è®©ä»£ç å—æ¢è¡Œæ˜¾ç¤ºè€Œä¸æ˜¯æ»šåŠ¨ï¼ˆä½¿ç”¨ cssText å¼ºåˆ¶è¦†ç›–ï¼‰
    const codeBlocks = clone.querySelectorAll('pre, pre.hljs, pre code, .hljs');
    codeBlocks.forEach(block => {
        block.style.cssText += `
            white-space: pre-wrap !important;
            word-wrap: break-word !important;
            word-break: break-all !important;
            overflow-x: visible !important;
            overflow: visible !important;
            max-width: 100% !important;
        `;
    });

    // 4. ä¿®å¤è¡Œå†…ä»£ç æ ·å¼ï¼ˆé¿å… html2canvas æ¸²æŸ“åç§»ï¼‰
    const inlineCodes = clone.querySelectorAll('code:not(pre code)');
    inlineCodes.forEach(code => {
        code.style.cssText += `
            display: inline !important;
            vertical-align: baseline !important;
            line-height: inherit !important;
            padding: 2px 6px !important;
            margin: 0 !important;
            position: relative !important;
            top: 0 !important;
        `;
    });

    document.body.appendChild(clone);

    // ç­‰å¾…ä¸€å°æ®µæ—¶é—´ç¡®ä¿æ ·å¼åº”ç”¨å’ŒæŸäº›èµ„æºåŠ è½½
    await new Promise(resolve => setTimeout(resolve, 150));

    try {
        const canvas = await html2canvas(clone, {
            backgroundColor: null,
            scale: 2, // é«˜æ¸…
            logging: false,
            useCORS: true,
            allowTaint: true,
            foreignObjectRendering: false,
            windowWidth: clone.scrollWidth,
            windowHeight: clone.scrollHeight
        });
        return canvas;
    } finally {
        // æ¸…ç† Clone
        if (clone && clone.parentNode) {
            clone.parentNode.removeChild(clone);
        }
    }
}

/**
 * ä¸‹è½½ DOM ä¸ºå›¾ç‰‡
 */
export async function downloadDOMAsImage(element, filename, options = {}) {
  try {
    const canvas = await renderElementToCanvas(element, options);

    const link = document.createElement('a');
    link.download = filename.endsWith('.png') ? filename : `${filename}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();

    return { success: true };
  } catch (error) {
    console.error('å¯¼å‡ºå›¾ç‰‡å¤±è´¥:', error);
    return { success: false, error: error.message };
  }
}

/**
 * å¤åˆ¶ DOM ä¸ºå›¾ç‰‡åˆ°å‰ªè´´æ¿
 */
export async function copyDOMAsImage(element, options = {}) {
  try {
    const canvas = await renderElementToCanvas(element, options);
    return new Promise((resolve) => {
        canvas.toBlob(async (blob) => {
            if (!blob) {
                resolve({ success: false, error: 'ç”Ÿæˆå›¾ç‰‡å¤±è´¥' });
                return;
            }
            try {
                // Clipboard API éœ€è¦ HTTPS æˆ– localhost
                const item = new ClipboardItem({ 'image/png': blob });
                await navigator.clipboard.write([item]);
                resolve({ success: true });
            } catch (err) {
                console.error('å†™å…¥å‰ªè´´æ¿å¤±è´¥:', err);
                resolve({ success: false, error: err.message });
            }
        });
    });
  } catch (error) {
    console.error('å¤åˆ¶å›¾ç‰‡å¤±è´¥:', error);
    return { success: false, error: error.message };
  }
}

/**
 * ä¸‹è½½ DOM ä¸º PDF
 */
export async function downloadDOMAsPDF(element, filename, options = {}) {
  try {
    const { jsPDF } = await import('jspdf');

    // ä½¿ç”¨é€šç”¨æ¸²æŸ“å‡½æ•°
    const canvas = await renderElementToCanvas(element, options);

    const imgData = canvas.toDataURL('image/png');
    // A4 å°ºå¯¸ (mm)
    const pdf = new jsPDF('p', 'mm', 'a4');
    const pdfWidth = 210;
    const pdfHeight = 297;

    // è®¡ç®—å›¾ç‰‡åœ¨ PDF ä¸­çš„å°ºå¯¸ï¼ˆä¿æŒæ¯”ä¾‹é€‚é…å®½åº¦ï¼‰
    const imgProps = pdf.getImageProperties(imgData);
    const imgHeight = (imgProps.height * pdfWidth) / imgProps.width;

    let heightLeft = imgHeight;
    let position = 0;

    // ç¬¬ä¸€é¡µ
    pdf.addImage(imgData, 'PNG', 0, position, pdfWidth, imgHeight);
    heightLeft -= pdfHeight;

    // åç»­é¡µ
    while (heightLeft > 0) {
      position = heightLeft - imgHeight; // è¿™é‡Œçš„è®¡ç®—æ˜¯: å½“å‰å‰©ä½™é¡¶éƒ¨ä½ç½®
      // å®é™…ä¸Š jspdf åˆ†é¡µæ·»åŠ å›¾ç‰‡çš„é€»è¾‘æ˜¯: è°ƒæ•´ y åæ ‡ä¸ºè´Ÿå€¼ï¼Œè®©å›¾ç‰‡ä¸Šç§»
      // position åº”è¯¥æ˜¯ -297, -594 ...
      // ä¿®æ­£ç®—æ³•ï¼š
      // Page 2: position should be -297

      pdf.addPage();
      // è®¡ç®—æ–°çš„åç§»é‡
      // ä¸Šä¸€æ¬¡çš„ position æ˜¯ 0ï¼ˆç›¸å¯¹äºç¬¬ä¸€é¡µé¡¶ç«¯ï¼‰
      // ä¸‹ä¸€é¡µæˆ‘ä»¬è¦æ˜¾ç¤ºçš„æ˜¯åŸæœ¬ 297mm å¤„çš„å†…å®¹ï¼Œè®©å®ƒå‡ºç°åœ¨æ–°é¡µé¢çš„ 0mm å¤„
      // æ‰€ä»¥ y = -297
      // æˆ‘ä»¬å¯ä»¥ç»´æŠ¤ä¸€ä¸ªç´¯åŠ çš„ offset

      // é‡ç½® position é€»è¾‘ï¼Œç›´æ¥ç”¨ page index
      const pageIndex = pdf.internal.getNumberOfPages() - 1; // 0-based, now 1
      position = -pageIndex * pdfHeight;

      pdf.addImage(imgData, 'PNG', 0, position, pdfWidth, imgHeight);
      heightLeft -= pdfHeight;
    }

    pdf.save(filename.endsWith('.pdf') ? filename : `${filename}.pdf`);
    return { success: true };
  } catch (error) {
    console.error('å¯¼å‡ºPDFå¤±è´¥:', error);
    return { success: false, error: error.message };
  }
}

/**
 * ä¸‹è½½ Markdown å­—ç¬¦ä¸²
 */
export function downloadMarkdownString(content, filename) {
    try {
        const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' });
        const link = document.createElement('a');
        link.download = filename.endsWith('.md') ? filename : `${filename}.md`;
        link.href = URL.createObjectURL(blob);
        link.click();
        URL.revokeObjectURL(link.href);
        return { success: true };
    } catch (error) {
        console.error('å¯¼å‡ºMarkdownå¤±è´¥:', error);
        return { success: false, error: error.message };
    }
}


// --- å…¼å®¹æ—§ API (Direct Export) ---

export async function exportAsImage(messages, title, isDark, messageIndices) {
    const element = prepareMacOSContainerDOM(messages, title, isDark, messageIndices);
    // æ”¾å…¥ body éšè—
    element.style.position = 'fixed';
    element.style.left = '-9999px';
    element.style.top = '0';
    document.body.appendChild(element);
    try {
        return await downloadDOMAsImage(element, `chat-export-${Date.now()}`);
    } finally {
        element.remove();
    }
}

export async function exportAsPDF(messages, title, isDark, messageIndices) {
    const element = prepareMacOSContainerDOM(messages, title, isDark, messageIndices);
    element.style.position = 'fixed';
    element.style.left = '-9999px';
    element.style.top = '0';
    document.body.appendChild(element);
    try {
        await new Promise(r => setTimeout(r, 100)); // wait for style
        return await downloadDOMAsPDF(element, `chat-export-${Date.now()}`);
    } finally {
        element.remove();
    }
}

export function exportAsMarkdown(messages, title, messageIndices) {
    const content = generateMarkdownContent(messages, title, messageIndices);
    return downloadMarkdownString(content, `chat-export-${Date.now()}`);
}
